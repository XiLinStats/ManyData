data_exp_b <- causalSamp(250,formulas = forms_exp,pars = pars_exp, family = list(1,c(5,5),1,1))
data_obs_b <- causalSamp(2500,formulas = forms_exp,pars = pars_exp, family = list(1,c(5,5),1,1))
for (i in 1:length(eta_list)){
fit <- fitCausalComb(dat_exp = data_exp_b, forms_exp = forms_exp,
dat_obs = data_obs_b, forms_obs = forms_obs,
family = c(1,1,1),
eta = eta)
var_beta_1 <- fit$sandwich[5,5]
var_beta_3 <- fit$sandwich[6,6]
cov_beta_13<- fit$sandwich[5,6]
var_ATE <- var_beta_1 + mean(data_exp_b$C1)^2*var_beta_3 +2* mean(data_exp_b$C1) *cov_beta_13
mean_ATE<- fit$par[5] + mean(data_exp_b$C1) *fit$par[6]
true_ATE <- beta_1_true + mean(data_exp_b$C1) *beta_3_true
cover[i] <- c(eta,1* (qnorm(0.975,mean_ATE, sqrt(var_ATE)) > true_ATE & true_ATE > qnorm(0.025,mean_ATE, sqrt(var_ATE))))
# cover <- 1* (qnorm(0.975,mean_ATE, sqrt(var_ATE)) > true_ATE & true_ATE > qnorm(0.025,mean_ATE, sqrt(var_ATE)))
}
return(cover)
}
func(c(0,1))
func <- function(eta_list){
cover <- matrix(NA,length(eta_list),2)
data_exp_b <- causalSamp(250,formulas = forms_exp,pars = pars_exp, family = list(1,c(5,5),1,1))
data_obs_b <- causalSamp(2500,formulas = forms_exp,pars = pars_exp, family = list(1,c(5,5),1,1))
for (i in 1:length(eta_list)){
eta <- eta_list[i]
fit <- fitCausalComb(dat_exp = data_exp_b, forms_exp = forms_exp,
dat_obs = data_obs_b, forms_obs = forms_obs,
family = c(1,1,1),
eta = eta)
var_beta_1 <- fit$sandwich[5,5]
var_beta_3 <- fit$sandwich[6,6]
cov_beta_13<- fit$sandwich[5,6]
var_ATE <- var_beta_1 + mean(data_exp_b$C1)^2*var_beta_3 +2* mean(data_exp_b$C1) *cov_beta_13
mean_ATE<- fit$par[5] + mean(data_exp_b$C1) *fit$par[6]
true_ATE <- beta_1_true + mean(data_exp_b$C1) *beta_3_true
cover[i] <- c(eta,1* (qnorm(0.975,mean_ATE, sqrt(var_ATE)) > true_ATE & true_ATE > qnorm(0.025,mean_ATE, sqrt(var_ATE))))
# cover <- 1* (qnorm(0.975,mean_ATE, sqrt(var_ATE)) > true_ATE & true_ATE > qnorm(0.025,mean_ATE, sqrt(var_ATE)))
}
return(cover)
}
func(c(0,1))
func <- function(eta_list){
cover <- matrix(NA,length(eta_list),2)
data_exp_b <- causalSamp(250,formulas = forms_exp,pars = pars_exp, family = list(1,c(5,5),1,1))
data_obs_b <- causalSamp(2500,formulas = forms_exp,pars = pars_exp, family = list(1,c(5,5),1,1))
for (i in 1:length(eta_list)){
eta <- eta_list[i]
fit <- fitCausalComb(dat_exp = data_exp_b, forms_exp = forms_exp,
dat_obs = data_obs_b, forms_obs = forms_obs,
family = c(1,1,1),
eta = eta)
var_beta_1 <- fit$sandwich[5,5]
var_beta_3 <- fit$sandwich[6,6]
cov_beta_13<- fit$sandwich[5,6]
var_ATE <- var_beta_1 + mean(data_exp_b$C1)^2*var_beta_3 +2* mean(data_exp_b$C1) *cov_beta_13
mean_ATE<- fit$par[5] + mean(data_exp_b$C1) *fit$par[6]
true_ATE <- beta_1_true + mean(data_exp_b$C1) *beta_3_true
cover[i,] <- c(eta,1* (qnorm(0.975,mean_ATE, sqrt(var_ATE)) > true_ATE & true_ATE > qnorm(0.025,mean_ATE, sqrt(var_ATE))))
# cover <- 1* (qnorm(0.975,mean_ATE, sqrt(var_ATE)) > true_ATE & true_ATE > qnorm(0.025,mean_ATE, sqrt(var_ATE)))
}
return(cover)
}
func(c(0,1))
qnorm(0.975,1,1)
qnorm(0.95,1,1)
qnorm(0.9,1,1)
qnorm(0.9,0,1)
qnorm(0.975,0,1)
func <- function(eta_list){
cover <- matrix(NA,length(eta_list),3)
data_exp_b <- causalSamp(250,formulas = forms_exp,pars = pars_exp, family = list(1,c(5,5),1,1))
data_obs_b <- causalSamp(2500,formulas = forms_exp,pars = pars_exp, family = list(1,c(5,5),1,1))
for (i in 1:length(eta_list)){
eta <- eta_list[i]
fit <- fitCausalComb(dat_exp = data_exp_b, forms_exp = forms_exp,
dat_obs = data_obs_b, forms_obs = forms_obs,
family = c(1,1,1),
eta = eta)
var_beta_1 <- fit$sandwich[5,5]
var_beta_3 <- fit$sandwich[6,6]
cov_beta_13<- fit$sandwich[5,6]
var_ATE <- var_beta_1 + mean(data_exp_b$C1)^2*var_beta_3 +2* mean(data_exp_b$C1) *cov_beta_13
mean_ATE<- fit$par[5] + mean(data_exp_b$C1) *fit$par[6]
true_ATE <- beta_1_true + mean(data_exp_b$C1) *beta_3_true
interval_length <- 2*qnorm(0.975,0,1)* sqrt(var_ATE)
cover[i,] <- c(eta,1* (qnorm(0.975,mean_ATE, sqrt(var_ATE)) > true_ATE & true_ATE > qnorm(0.025,mean_ATE, sqrt(var_ATE))),interval_length)
# cover <- 1* (qnorm(0.975,mean_ATE, sqrt(var_ATE)) > true_ATE & true_ATE > qnorm(0.025,mean_ATE, sqrt(var_ATE)))
}
return(cover)
}
func(c(0,1))
# Startup -----------------------------------------------------------------
library(causl)
library(ManyData)
library(data.table)
library(survey)
library(mvtnorm)
library(doParallel)
library(loo)
library(coda)
library(coda)
library(parallel)
library(foreach)
library(doSNOW)
library(numDeriv)
# Functions ---------------------------------------------------------------
# eta <- 0.5
# dat_exp <- data_exp
# dat_obs <- data_obs
#
#
# LHS <- c("Z","Y")
#
# family = c(1,1,1)
# eta = 0.5
combined_nll <- function(theta,dat_exp,mm_exp,beta_exp,phi_exp,
dat_obs, mm_obs,beta_obs,phi_obs,
inCop,
fam_cop = 1,
family,
eta
){
exp_nll <- causl:::nll2(
theta,
dat_exp,
mm_exp,
beta_exp,
phi = phi_exp,
inCop = inCop,
fam_cop = fam_cop,
family
)
obs_nll <- causl:::nll2(
theta,
dat_obs,
mm_obs,
beta_obs,
phi = phi_obs,
inCop = inCop,
fam_cop = fam_cop,
family
)
comb_nll <- exp_nll + eta * obs_nll
return(comb_nll)
}
# combined_nll(theta_exp,data_exp[,c("Z","Y")],mm_exp,msks_exp$beta_m,msks_exp$phi_m,
#              data_obs[,c("Z","Y")],mm_obs,msks_obs$beta_m,msks_obs$phi_m,
#              inCop = c(1,2),
#              fam_cop = 1,
#              family = c(1,1),
#              eta = 0.5
# )
fitCausalComb <- function(dat_exp, forms_exp,
dat_obs, forms_obs,
family,
eta
){
con <- list(
trace = 0, fnscale = 1, maxit = 10000L, abstol = -Inf,
reltol = sqrt(.Machine$double.eps), alpha = 1, beta = 0.5,
gamma = 2, REPORT = 10, warn.1d.NelderMead = TRUE, type = 1,
lmm = 5, factr = 1e+07, pgtol = 0, tmax = 10)
forms2_obs <- causl:::tidy_formulas(forms_obs[-2], kwd = "cop")
full_form_obs <- causl:::merge_formulas(forms2_obs)
wh_obs <- full_form_obs$wh
# LHS <- lhs(forms2[-length(forms2)])
msks_obs <- ManyData:::masks(forms_obs[-2],family = list(1,1,1),wh_obs)
# theta_obs <- causl:::theta(pars = pars_obs, formulas = forms_obs[-2], full_form_obs, kwd = "cop")
mm_obs <- model.matrix(full_form_obs$formula, data = dat_obs)
forms2_exp <- causl:::tidy_formulas(forms_exp[-2], kwd = "cop")
full_form_exp <- causl:::merge_formulas(forms2_exp)
wh_exp <- full_form_exp$wh
# LHS <- lhs(forms2[-length(forms2)])
msks_exp <- ManyData:::masks(forms_exp[-2],family = list(1,1,1),wh_exp)
# theta_exp <- causl:::theta(pars = pars_exp, formulas = forms_exp[-2], full_form_exp, kwd = "cop")
mm_exp <- model.matrix(full_form_exp$formula, data = dat_exp)
fam_cop <- last(family)
LHS <- causl:::lhs(forms2_exp[-length(forms2_exp)])
beta_start2 <- causl:::initializeParams2(dat_exp[c("Z","Y")], formulas = forms2_exp,
family = family, link = NULL, full_form = full_form_exp,
kwd = "cop")
theta_st <- c(beta_start2$beta[beta_start2$beta_m > 0],
beta_start2$phi[beta_start2$phi_m > 0])
# combined_nll(theta_st,data_exp[,c("Z","Y")],mm_exp,msks_exp$beta_m,msks_exp$phi_m,
#              data_obs[,c("Z","Y")],mm_obs,msks_obs$beta_m,msks_obs$phi_m,
#              inCop = c(1,2),
#              fam_cop = 1,
#              family = c(1,1),
#              eta = 0.5
# )
other_args2 <- list(dat_exp = dat_exp[c("Z","Y")] ,mm_exp = mm_exp, beta_exp = msks_exp$beta_m,phi_exp = msks_exp$phi_m,
dat_obs = dat_obs[c("Z","Y")], mm_obs = mm_obs, beta_obs = msks_obs$beta_m,phi_obs = msks_obs$phi_m,
inCop = seq_along(LHS), fam_cop = fam_cop, fam = family[-length(family)],
eta = eta)
maxit <- con$maxit
conv <- FALSE
out2 <- list(par = theta_st)
while (!conv) {
con$maxit <- min(maxit, 5000)
out <- do.call(optim, c(list(fn = combined_nll, par = theta_st),
other_args2, list(method = "Nelder-Mead", control = con)))
con$maxit <- min(max(maxit - 5000, 1000), maxit)
out2 <- tryCatch(do.call(optim, c(list(fn = combined_nll, par = out$par),
other_args2, list(method = "BFGS", control = con))),
warning = function(e) NA, error = function(e) NA)
if (!isTRUE(is.na(out2))) {
out <- out2
conv <- TRUE
}
else out2 <- list(par = out$par)
}
other_args2_exp <- list(dat = dat_exp[c("Z","Y")], mm = mm_exp,
beta = msks_exp$beta_m, phi = msks_exp$phi_m,
inCop = seq_along(LHS), fam_cop = fam_cop, fam = family[-length(family)],
par2 = NULL, useC = TRUE)
other_args2_obs <- list(dat = dat_obs[c("Z","Y")], mm = mm_obs,
beta = msks_obs$beta_m, phi = msks_obs$phi_m,
inCop = seq_along(LHS), fam_cop = fam_cop, fam = family[-length(family)],
par2 = NULL, useC = TRUE)
# Calculate outer product of gradient
other_args2a_exp <- other_args2_exp
other_args2a_obs <- other_args2_obs
gr2 <- matrix(0, nrow = length(theta_st), ncol = length(theta_st))
for (i in seq_len(nrow(dat_exp))) {
other_args2a_exp$dat <- other_args2_exp$dat[i, ]
other_args2a_exp$mm <- other_args2_exp$mm[i, , drop = FALSE]
tmp <- do.call(grad, c(list(causl:::nll2, x = out$par),
other_args2a_exp))
gr2 <- gr2 + outer(tmp, tmp)
}
for (i in seq_len(nrow(dat_obs))) {
other_args2a_obs$dat <- other_args2_obs$dat[i, ]
other_args2a_obs$mm <- other_args2_obs$mm[i, , drop = FALSE]
tmp <- do.call(grad, c(list(causl:::nll2, x = out$par),
other_args2a_obs))
gr2 <- gr2 + eta^2 * outer(tmp, tmp)
}
out$FI <- do.call(hessian, c(list(causl:::nll2, x = out$par), other_args2_exp)) + eta * do.call(hessian, c(list(causl:::nll2, x = out$par), other_args2_obs))
if (!any(is.na(out$FI)) && rcond(out$FI) > 1e-16) {
invFI <- solve.default(out$FI)
}
else {
invFI <- tryCatch(MASS::ginv(out$FI), error = function(e) NA)
}
if (is.numeric(invFI)) {
out$se = sqrt(pmax(0, diag(invFI)))
}
else out$se <- NULL
if (!is.null(out$se)) {
out$sandwich <- invFI %*% gr2 %*% invFI
out$sandwich_se <- sqrt(diag(out$sandwich))
}
else {
out$sandwich <- out$sandwich_se <- NULL
}
return(out)
}
# Parameters --------------------------------------------------------------
bias_1 <- 0
bias_2 <- 0
forms_obs <- list(Z ~ C1,
list(X ~ Z*C1,C1~ 1),
Y ~ X*C1,
~ X*C1 #copula
)
# parameters
pars_obs <- list(C1 = list(beta = 0),
Z = list(beta = c(0.2,0.6),phi = 1),
X = list(beta = c(0.5,0.6,0.1,0.4)),
Y = list(beta = c(0.6,0.8 + bias_1 ,0.2,0.3+ bias_2),phi = 1),
cop = list(beta = matrix(c(1,0,0,0),nrow = 4)))
forms_exp <- list(Z ~ C1,
list(X ~ 1,C1~ 1),
Y ~ X*C1,
~ X*C1 #copula
)
# parameters
pars_exp <- list(C1 = list(beta = 0),
Z = list(beta = c(0.2,0.6),phi = 1),
X = list(beta = c(0)),
Y = list(beta = c(0.6,0.8,0.2,0.3),phi = 1),
cop = list(beta = matrix(c(1,0,0,0),nrow = 4)))
# Parallelisation ---------------------------------------------------------
parallel::detectCores()
# [1] 12
n.cores <- parallel::detectCores() - 1
# n.cores <- 38
my.cluster <- parallel::makeCluster(
n.cores,
type = "PSOCK"
)
print(my.cluster)
#register it to be used by %dopar%
doParallel::registerDoParallel(cl = my.cluster)
#check if it is registered (optional)
foreach::getDoParRegistered()
registerDoSNOW(my.cluster)
# -------------------------------------------------------------------------
func <- function(eta_list){
cover <- matrix(NA,length(eta_list),3)
data_exp_b <- causalSamp(250,formulas = forms_exp,pars = pars_exp, family = list(1,c(5,5),1,1))
data_obs_b <- causalSamp(2500,formulas = forms_exp,pars = pars_exp, family = list(1,c(5,5),1,1))
for (i in 1:length(eta_list)){
eta <- eta_list[i]
fit <- fitCausalComb(dat_exp = data_exp_b, forms_exp = forms_exp,
dat_obs = data_obs_b, forms_obs = forms_obs,
family = c(1,1,1),
eta = eta)
var_beta_1 <- fit$sandwich[5,5]
var_beta_3 <- fit$sandwich[6,6]
cov_beta_13<- fit$sandwich[5,6]
var_ATE <- var_beta_1 + mean(data_exp_b$C1)^2*var_beta_3 +2* mean(data_exp_b$C1) *cov_beta_13
mean_ATE<- fit$par[5] + mean(data_exp_b$C1) *fit$par[6]
true_ATE <- beta_1_true + mean(data_exp_b$C1) *beta_3_true
interval_length <- 2*qnorm(0.975,0,1)* sqrt(var_ATE)
cover[i,] <- c(eta,1* (qnorm(0.975,mean_ATE, sqrt(var_ATE)) > true_ATE & true_ATE > qnorm(0.025,mean_ATE, sqrt(var_ATE))),interval_length)
# cover <- 1* (qnorm(0.975,mean_ATE, sqrt(var_ATE)) > true_ATE & true_ATE > qnorm(0.025,mean_ATE, sqrt(var_ATE)))
}
return(cover)
}
func(c(0,1))
# Parallel ----------------------------------------------------------------
eta_list <- c(0,1)
start <- Sys.time()
results <- foreach(
i = 1:2,
.combine = 'rbind',
.packages = c('data.table','numDeriv','ManyData','causl')
# .options.snow = opts
) %dopar% {
x<-func(1)
return(x)
}
Sys.time() - start
eta_list <- c(0,1)
start <- Sys.time()
results <- foreach(
i = 1:2,
.combine = 'rbind',
.packages = c('data.table','numDeriv','ManyData','causl')
# .options.snow = opts
) %dopar% {
x<-func(1)
return(x)
}
Sys.time() - start
mean(results)
eta_list <- c(0,1)
start <- Sys.time()
results <- foreach(
i = 1:2,
.combine = 'rbind',
.packages = c('data.table','numDeriv','ManyData','causl')
# .options.snow = opts
) %dopar% {
x<-func(eta_list)
return(x)
}
Sys.time() - start
parallel::detectCores()
# [1] 12
n.cores <- parallel::detectCores() - 1
# n.cores <- 38
my.cluster <- parallel::makeCluster(
n.cores,
type = "PSOCK"
)
print(my.cluster)
#register it to be used by %dopar%
doParallel::registerDoParallel(cl = my.cluster)
#check if it is registered (optional)
foreach::getDoParRegistered()
registerDoSNOW(my.cluster)
func <- function(eta_list){
cover <- matrix(NA,length(eta_list),3)
data_exp_b <- causalSamp(250,formulas = forms_exp,pars = pars_exp, family = list(1,c(5,5),1,1))
data_obs_b <- causalSamp(2500,formulas = forms_exp,pars = pars_exp, family = list(1,c(5,5),1,1))
for (i in 1:length(eta_list)){
eta <- eta_list[i]
fit <- fitCausalComb(dat_exp = data_exp_b, forms_exp = forms_exp,
dat_obs = data_obs_b, forms_obs = forms_obs,
family = c(1,1,1),
eta = eta)
var_beta_1 <- fit$sandwich[5,5]
var_beta_3 <- fit$sandwich[6,6]
cov_beta_13<- fit$sandwich[5,6]
var_ATE <- var_beta_1 + mean(data_exp_b$C1)^2*var_beta_3 +2* mean(data_exp_b$C1) *cov_beta_13
mean_ATE<- fit$par[5] + mean(data_exp_b$C1) *fit$par[6]
true_ATE <- beta_1_true + mean(data_exp_b$C1) *beta_3_true
interval_length <- 2*qnorm(0.975,0,1)* sqrt(var_ATE)
cover[i,] <- c(eta,1* (qnorm(0.975,mean_ATE, sqrt(var_ATE)) > true_ATE & true_ATE > qnorm(0.025,mean_ATE, sqrt(var_ATE))),interval_length)
# cover <- 1* (qnorm(0.975,mean_ATE, sqrt(var_ATE)) > true_ATE & true_ATE > qnorm(0.025,mean_ATE, sqrt(var_ATE)))
}
return(cover)
}
eta_list <- c(0,1)
start <- Sys.time()
results <- foreach(
i = 1:2,
.combine = 'rbind',
.packages = c('data.table','numDeriv','ManyData','causl')
# .options.snow = opts
) %dopar% {
x<-func(eta_list)
return(x)
}
Sys.time() - start
beta_1_true <- 0.8
beta_1_true <- 0.3
eta_list <- c(0,1)
start <- Sys.time()
results <- foreach(
i = 1:2,
.combine = 'rbind',
.packages = c('data.table','numDeriv','ManyData','causl')
# .options.snow = opts
) %dopar% {
x<-func(eta_list)
return(x)
}
Sys.time() - start
mean(results)
beta_1_true <- 0.8
beta_3_true <- 0.3
eta_list <- c(0,1)
start <- Sys.time()
results <- foreach(
i = 1:2,
.combine = 'rbind',
.packages = c('data.table','numDeriv','ManyData','causl')
# .options.snow = opts
) %dopar% {
x<-func(eta_list)
return(x)
}
Sys.time() - start
mean(results)
results
colnames(results) <- c("eta","cover_ind","int_length")
results
library(gridExtra)
library(ggplot2)
library(data.table)
library(grid )
result_path <- "D:/xlin/R_code/Server/ELPD_results"
large_bias <- readRDS(file.path(result_path,"large_bias_results.rds"))
beta_1_true <- 0.8
beta_3_true <- 0.3
# ATE_true <- beta_1_true + beta_3_true * expit(0)
create_plot <- function(result, title){
result[,ATE:= beta_1 + beta_3 * meanC1_exp]
summ<-result[,.(.N,
AR = mean(AR),
ESS = mean(ESS),
beta_1 = mean(beta_1),
beta_1sd = sd(beta_1),
beta_3 = mean(beta_3),
beta_3sd = sd(beta_3),
ATE = mean(ATE),
ATE_sd = sd(ATE),
elpd = mean(ELPD_waic),
RMSE_beta1 = sqrt(mean((beta_1 - beta_1_true)^2)),
RMSE_beta3 = sqrt(mean((beta_3 - beta_3_true)^2)),
MSE_ATE = mean((ATE - (beta_1_true + beta_3_true *meanC1_exp ))^2),
Bias = (mean(ATE - (beta_1_true + beta_3_true *meanC1_exp )))^2,
Variance = mean((ATE - (beta_1_true + beta_3_true *meanC1_exp )  - mean(ATE - (beta_1_true + beta_3_true *meanC1_exp )))^2)
),
,eta]
p1 <- ggplot(summ, aes(x = eta)) +
geom_line(aes(y = -elpd), color = "darkred", size = 1) +
ggtitle("Estimated ELPD")+
theme_bw()
p2 <- ggplot(summ, aes(x = eta)) +
geom_line(aes(y = RMSE_beta1), color = "darkred", size = 1) +
ggtitle("RMSE beta1")+
theme_bw()
p3 <- ggplot(summ, aes(x = eta)) +
geom_line(aes(y = RMSE_beta3), color = "darkred", size = 1) +
ggtitle("RMSE beta3")+
theme_bw()
# p4 <- ggplot(summ, aes(x = eta)) +
#   geom_line(aes(y = MSE_ATE), color = "darkred", size = 1) +
#   ggtitle("MSE ATE")+
#   theme_bw()
summ1<- melt(summ, id.vars = c('eta'),
measure.vars = c("Bias", "Variance"))
p4 <- ggplot(summ1, aes(x=eta, y=value)) +
geom_area(aes(fill=variable) , alpha = 0.6) +
theme_bw() + theme(legend.position = c(0.81,0.88)) +
guides(fill=guide_legend(title="Decomposition"))+
theme(legend.title = element_text(size=10),
legend.key.height = unit(0.1, 'cm'),
legend.background = element_rect(fill='transparent',))+
stat_summary(fun = sum, geom = "line", size = 1, color = "darkred")+
ggtitle("MSE ATE")
p5 <- ggplot(summ, aes(x = eta)) +
geom_line(aes(y = AR), color = "darkred", size = 1) +
ggtitle("AR")+
theme_bw()
p6 <- ggplot(summ, aes(x = eta)) +
geom_line(aes(y = ESS), color = "darkred", size = 1) +
ggtitle("ESS")+
theme_bw()
# p5 <- ggplot(summ, aes(x = eta)) +
#   geom_line(aes(y = mean_cov_prob), color = "darkred", size = 1) +
#   ggtitle("Coverage probability (ATE)")+
#   theme_bw()
grid.arrange(p1,p2,p3,p4,nrow = 2,top = textGrob(title,gp=gpar(fontsize=20,font=3)))
# grid.arrange(p5,p6,nrow = 1,top = textGrob(title,gp=gpar(fontsize=20,font=3)))
return(summ)
}
create_plot(large_bias, title = "Large bias (2 se)")
